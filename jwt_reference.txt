There are two types of authentication: 
1. session storage in database
When a user logs in, a unique session ID is generated and stored in the database. 
This ID is then sent to the client (frontend), which uses it to authenticate subsequent requests by sending it back to the server (API).


2. JWT - JSON Web Token (session info not stored, hence it is stateless)

JWT token is something the fronend sends the API when a user logs in.
The API checks the tokens validity and if yes, sends the data.
Note that the token is NOT encrypted. It has a meaning

**GPT**: JWT is a compact, URL-safe means of representing claims to be transferred between two parties. In this method, when a user logs in, the server (API) generates a JWT containing encoded user information. 
This token is then sent to the client and included in subsequent requests to the server. The server validates the token to ensure its authenticity and extracts information from it to process the request.
Regarding JWT:
Stateless nature: The server doesn't store the token itself; it validates it based on its digital signature or other verification methods (e.g., shared secret).
Token content: While JWTs are not typically encrypted (they're encoded in a JSON format), they can be digitally signed to ensure data integrity.

In JWT (JSON Web Token), the token itself is divided into three parts: Header, Payload, and Signature. Hereâ€™s an overview of each part:

1. Header:
The header typically consists of two parts: the type of the token (which is JWT) and the signing algorithm being used, such as HMAC SHA256 or RSA.
Example of a JWT header:
{
  "alg": "HS256",
  "typ": "JWT"
}
This JSON object is base64url-encoded to form the first part of the JWT.

2.Payload:

The payload contains the claims. Claims are statements about an entity (typically the user) and additional data. There are three types of claims: reserved, public, and private claims.
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
This JSON object is also base64url-encoded to form the second part of the JWT.

3. Signature:

The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.
To create the signature, the header and payload are combined with a secret (or a private key in case of asymmetric algorithms) and then encoded using the algorithm specified in the header.


Example of a JWT (not a full JWT, but it gives an idea of its structure):
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ

This example consists of three parts separated by dots (.):
Header: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
Payload: eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
Signature: The last part is the actual signature generated by combining the encoded header, the encoded payload, and a secret key.

Since JWT is not encrypted and is only signed to check if the data is tampered with or not, DO NOT add confidential info in the apyload.
Add those cols whose info is unique and helpful to retrieve info qbout the user.

Overview:
We have three things: header, payload, signature
The signature is generated from hashing the header, payload and the secret (super safe bunch of characters which no one unauthenticated has access to)
So if someone has the JWT, doesn't matter as header and pyload as not of much use and he cannot reverse-engineer the secret via the signature.
Even if he/she tries to change the header/payload, he won't be able to generate the same hash/signature as he/she doesn't have the secret. Hence, no breach.