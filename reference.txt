conda activate api
pip install fastapi[all] -- for not having to install manual dependencies
pip freeze (to show all installed packages)
python -m uvicorn main:app (main is the file and app is the instance of fastapi
                           note that --reload ensures that whenever you change your code and save, you don't have to restart the server)

If your main files exists in a folder, which is treated as a python package, run this cmd to start server:
python -m uvicorn app.main:app

pip install psycopg2 (for postgres connection)

pip install passlib[bcrypt] - for hashing passwords
pip install python-jose[cryptography] - for signing JWT

pip install alembic

now if you have the authorization in place, before creating a post (or whatever endpoint needs authorization), go to headers and add:
Key: Authorization, Value: Bearer <token_generated_while_logging_in>

Use Postman Environments feature to ensure that your application works on all kinds of servers/protocols you want!
(instead of hard coding those variables based off on local system)

Now it is a pain to login, copy-paste and test the api everytime the token expires.
1. To solve this, you can go to scripts in the login endpoint on postman
2. Add this command: pm.environment.set("JWT",pm.response.json().access_token);
3. Go to each endpoint to be tested and add {{JWT}} as value for 'Token' key in Authorization
4. This dynamically updates the token
5. So each time the token expires, all you need to do is login

One-to-Many relationship: user can create many posts but a post can be associated with only one user.
Foreign key solves the relational problem (hence, R-DBMS)
Your foreign key datatype MUST match the reference table datatype
Name of foreign key doesn't matter but the convention is: <our-table>_<reference-table>_fkey
Eg: posts_users_fkey
Code to do this through psql: ALTER TABLE posts ADD COLUMN user_id integer NOT NULL;
ALTER TABLE posts ADD CONSTRAINT posts_user_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
One delete cascade means if a user is deleted, the associated posts also get deleted.

But if you are using sqlalchemy (orm), do it through it only, just for continuity.

Code: \d posts; (for table description)


About environment variables:
Either you can set it up in your OS or create a env file

To do in OS (not recommended at all):

Add an env variable --> create a file.py and add code: 
import os
path = os.getenv("MY_DB_URL")


COMPOSITE KEY: primary key of 2 cols. Here the condition is not null and unique for the composite row!  

SQL JOINS (checkout Postgres tutorials site for excellent explanation)
Code: SELECT title, content, email FROM posts LEFT JOIN users ON posts.owner_id = users.id;
(if the tables have a common column name (eg: id) & you want to retrieve the one from users, say users.id)
eg: SELECT users.id, posts.* FROM posts LEFT JOIN users ON posts.owner_id = users.id;
(posts.* retreives all cols from posts)
Retrieves all cols: SELECT * FROM posts LEFT JOIN users ON posts.owner_id = users.id;

1st table referenced in code line: LEFT TABLE (here, posts)
2nd table: RIGHT TABLE

Types of joins:
1. An INNER JOIN returns only the rows where there is a match in both tables. If there is no match, the row is not returned.
2. A LEFT JOIN returns all the rows from the left table and the matched rows from the right table. If there is no match, the result is NULL on the side of the right table.
3. A RIGHT JOIN returns all the rows from the right table and the matched rows from the left table. If there is no match, the result is NULL on the side of the left table.
4. A FULL JOIN returns all the rows when there is a match in either the left table or the right table. If there is no match, the result is NULL from the side that does not have a match.
5. A CROSS JOIN returns the Cartesian product of the two tables. This means that it returns all possible combinations of rows from the two tables.
6. A SELF JOIN is a regular join but the table is joined with itself. It is useful for comparing rows within the same table.



